/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
#include "STM32F103C6.h"
#include "GPIO.h"
#include "USART.h"
#include "SPI.h"
#include "I2C.h"
#include "EXTI.h"

extern int _estack ;


#define OS_SET_PSP(add)				__asm("MOV R0,%0 \t\n MSR PSP,R0" : :"r"(add))
#define OS_Switch_SP_PSP			__asm("MRS R0,CONTROL \t\n ORR R0,R0,#0x2 \t\n MSR CONTROL,R0")
#define OS_Switch_SP_MSP			__asm("MRS R0,CONTROL \t\n AND R0,R0,#0x5 \t\n MSR CONTROL,R0")
#define OS_Generate_Interrupt       __asm("SVC #0x3")

#define CPU_Access_Level_Unprivileged(){__asm("MRS R3,CONTROL");\
		__asm("ORR R3,R0,#0x01");\
		__asm("MSR CONTROL,R3");\
}

#define CPU_Access_Level_Privileged(){__asm("MRS R3,CONTROL");\
		__asm("LSR R3,R3,#0x01");\
		__asm("LSL R3,R3,#0x01");\
		__asm("MSR CONTROL,R3");\
}

#define TaskA_Size 				100
#define TaskB_Size 				100

uint32_t _S_MSP=&_estack;
uint32_t _E_MSP;
//Stack pointer task A
uint32_t _S_PSP_TA;
uint32_t _E_PSP_TA;
//Stack pointer task B
uint32_t _S_PSP_TB;
uint32_t _E_PSP_TB;
//flag
uint8_t Flag_Task_A=0;
uint8_t Flag_Task_B=0;
uint8_t Flag=0;
void SVC_Handler (void)
{
	CPU_Access_Level_Privileged();
}

void EXTI_9 (void)
{
	if(Flag==0)
	{
		Flag_Task_A=1;
		Flag=1;
	}
	else if(Flag==1)
	{
		Flag_Task_B=1;
		Flag=0;
	}
}
uint8_t Task_A(uint8_t x,uint8_t y)
{
	uint8_t sum=x+y;
	return sum;
}

uint8_t Task_B(uint8_t x,uint8_t y)
{
	uint8_t sub=x-y;
	return sub;
}

void main_os(void)
{
	//init main stack pointer
	_E_MSP=_S_MSP-512;
	//init PSP Task A
	_S_PSP_TA=_E_MSP-8;
	_E_PSP_TA=_S_PSP_TA-TaskA_Size;
	//init PSP Task B
	_S_PSP_TB=_E_PSP_TA-8;
	_E_PSP_TB=_S_PSP_TB-TaskB_Size;
	while(1)
	{
		if(Flag_Task_A==1)
		{
			uint8_t sum;
			Flag_Task_A=0;
			//set PSP
			OS_SET_PSP(_S_PSP_TA);
			//switch to PSP
			OS_Switch_SP_PSP;
			// switch to unprivileged mode
			CPU_Access_Level_Unprivileged();
			sum=Task_A(5, 10);
			//Generate Interrupt to switch to privileged mode
			OS_Generate_Interrupt;
			//set MSP
			OS_Switch_SP_MSP;
		}
		else if(Flag_Task_B==1)
		{
			uint8_t sub;
			Flag_Task_B=0;
			//set PSP
			OS_SET_PSP(_S_PSP_TB);
			//switch to PSP
			OS_Switch_SP_PSP;
			// switch to unprivileged mode
			CPU_Access_Level_Unprivileged();
			sub=Task_B(50, 10);
			//Generate Interrupt to switch to privileged mode
			OS_Generate_Interrupt;
			//set MSP
			OS_Switch_SP_MSP;
		}
	}
}
int main(void)
{
	RCC_GPIOA_CLK_EN();
	RCC_GPIOB_CLK_EN();
	RCC_AFIO_CLK_EN();

	EXTI_PinConfig_t INT={
			.EXTI_PIN=EXTI9PB9,
			.IRQ_EN=1,
			.Trigger_Case=EXTI_Trigger_RISING,
			.P_IRQ_CallBack=EXTI_9
	};

	MCAL_EXTI_GPIO_Init(&INT);
	main_os();

	/* Loop forever */
	for(;;);
}
